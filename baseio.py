## This file is part of conftron.  
## 
## Copyright (C) 2011 Matt Peddie <peddie@jobyenergy.com>
## 
## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.

import genconfig

h_file_head = """
/* This file is part of conftron.  
 * 
 * Copyright (C) 2011 Matt Peddie <peddie@jobyenergy.com>
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *
 * ==================================================================
 * This file is automatically generated by lcmgen.py.  Do not edit it
 * yourself!  Instead, change the XML configuration that informs the
 * generation process.  
 * ==================================================================
 */
"""

parse_type_error = """
Warning: XML parser encountered an object of type `%(msg_tag)s' 
in file `%(filename)s.xml.'  Either the XML is broken 
(check for typos?) or support for this type is not yet implemented.
"""

## Utility parent classes that let you write properly formed C, Octave
## and LCM files.
class CHeader():
    def __init__(self):
        pass

    def to_h(self, name, output_f):
        cf = open(name + ".h", 'w')
        cf.write(h_file_head + "\n")
        hname = name.replace("/", "_").upper()
        cf.write("#ifndef __" + hname + "_H__\n")
        cf.write("#define __" + hname + "_H__\n\n")
        output_f(cf)
        cf.write("\n\n#endif // __" + hname + "_H__\n")
        cf.close()
        # print "Autogenerated file `" + name + ".h'."

    def cpp_wrap(self, strin):
        return """
#ifdef __cplusplus
extern "C"{
#endif

%(str)s

#ifdef __cplusplus
}
#endif
""" % {"str":strin}

class CCode():
    def __init__(self):
        pass
    def to_c(self, name, output_f):
        def tmp_output_f(cf):
            cf.write("#include \"" + name + ".h\"\n\n")
            output_f(cf)
        self.to_c_no_h(name, tmp_output_f)

    def to_c_no_h(self, name, output_f):
        cf = open(name + ".c", "w")
        cf.write(h_file_head + "\n")
        output_f(cf)
        cf.close()
        # print "Autogenerated file `" + name + ".c'."

class OctaveCode():
    def __init__(self):
        pass
    def to_octave_code(self, name, output_f):
        cf = open(name + ".m", "w")
        output_f(cf)
        cf.close()
        # print "Autogenerated file `" + name + ".m'."

class LCMFile():
    def __init__(self):
        pass
 
    def to_lcm(self, name, output_f):
        lf = open(name + ".lcm", 'w')
        lf.write(h_file_head + "\n")
        lf.write("package " + name + ";\n")
        output_f(lf)
        lf.close()
        # print "Autogenerated file `" + name + ".lcm'."
   
class ImADictionary():
    def __init__(self):
        pass
    def __getitem__(self, item):
        return getattr(self, item)

    def __setitem__(self, item, value):
        return setattr(self, item, value)

    def has_key(self, key):
        try:
            getattr(self, key)
        except AttributeError:
            return False
        else:
            return True

class TagInheritance(ImADictionary):
    reserved = genconfig.reserved_tag_names
    def __init__(self):
        pass

    def _inherit(self, parent):
        for tag, value in parent.__dict__.iteritems():
            if not tag in self.reserved:
                if not self.has_key(tag):
                    self[tag] = value

class Searchable():
    def __init__(self):
        pass

    def _search(self, collection, searchname):
        try:
            return (i for i in collection if i.name == searchname).next()
        except StopIteration:
            return None

    def _recsearch(self, collection, searchname):
        try:
            return (i for i in collection if i.name == searchname).next()
        except StopIteration:
            try:
                return (i.search(searchname) for i in collection if i.search(searchname)).next()
            except StopIteration:
                return None

    def _dictsearch(self, dictionary, searchname):
        if dictionary.has_key(searchname):
            return dictionary[searchname]

    def _dictrecsearch(self, dictionary, searchname):
        if dictionary.has_key(searchname):
            return dictionary[searchname]
        else:
            return (v for k,v in dictionary.iteritems() if v.search(searchname)).next()
