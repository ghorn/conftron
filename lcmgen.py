## This file is part of conftron.  
## 
## Copyright (C) 2011 Matt Peddie <peddie@jobyenergy.com>
## 
## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.

from xml.etree import ElementTree as ET
import xml.parsers.expat as expat
from sys import exit, argv
from os.path import dirname

sim_flag = "SIMULATOR_COMPILE_FLAG"
timestep = "DT"
telemetry_folder = "telemetry"
settings_folder = "settings"
lcm_folder = "auto"
lcm_basic = "lcm_telemetry_new"
stubs_folder = "stubs"
config_folder = "../conf"

h_file_head = """
/* This file is part of conftron.  
 * 
 * Copyright (C) 2011 Matt Peddie <peddie@jobyenergy.com>
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *
 * ==================================================================
 * This file is automatically generated by lcmgen.py.  Do not edit it
 * yourself!  Instead, change the XML configuration that informs the
 * generation process.  
 * ==================================================================
 */
"""

## Parsing errors
parse_settings_nobounds = """\
Error: Settings generation couldn't derive a set of bounds 
for field `%(f)s' in section `%(s)s'.  

Make sure you've specified either a `max' and `min' value or an
`absmax' for symmetric zero-mean bounds.
""" 

parse_settings_noval = """\
Error: Settings generation couldn't derive a(n) `%(sp)s' value 
for field `%(f)s' in section `%(s)s'.  

You must specify this value either for the entire section or for each
field within the section.  (If both are specified, the value inside
the field tag will take precedence.)
"""

parse_type_error = """\ 
Warning: XML parser encountered an object of type `%(msg_tag)s' 
in file `%(filename)s.xml.'  Either the XML is broken 
(check for typos?) or support for this type is not yet implemented.
"""

## Init all lcm stuff
lcm_init_call_template = "  %(classname)s_lcm_init(provider);  \\"

lcm_init_all_template = """
#define lcm_init(provider) { \\
%(init_calls)s } 
"""

lcm_init_prototype_template = "void %(classname)s_lcm_init(const char *provider);\n"

lcm_init_template = """
void
%(classname)s_lcm_init(const char *provider)
{
  if (%(classname)s_lcm.lcm == NULL)
    lcm_initialize(provider, &%(classname)s_lcm.lcm, &%(classname)s_lcm.fd);
}
"""

## Run telemetry functions
lcm_run_prototype_template = "void %(classname)s_telemetry_send(void);"

lcm_run_call_template = "  %(classname)s_telemetry_send();  \\"

lcm_run_all_template = """
#define telemetry_send() { \\
%(run_calls)s }
"""

lcm_telemetry_template = """
void 
%(classname)s_%(varname)s_send(int counter)
{
#ifdef %(sim_flag)s
  if ((counter %% ((int) (1.0/(%(timestep)s * %(simrate)s)))) == 0) 
#else
  if ((counter %% ((int) (1.0/(%(timestep)s * %(flightrate)s)))) == 0) 
#endif // %(sim_flag)s
    %(classname)s_lcm_send_chan(&%(varname)s, %(typename)s, "%(classname)s_%(typename)s_%(varname)s");
}
"""

lcm_telemetry_custom_chan_template = """
void 
%(classname)s_%(varname)s_send(int counter)
{
#ifdef %(sim_flag)s
  if ((counter %% ((int) (1.0/(%(timestep)s * %(simrate)s)))) == 0) 
#else
  if ((counter %% ((int) (1.0/(%(timestep)s * %(flightrate)s)))) == 0) 
#endif // %(sim_flag)s
    %(classname)s_lcm_send_chan(&%(varname)s, %(typename)s, "%(channel)s");
}
"""

lcm_telemetry_nop_template = """
void 
%(classname)s_%(varname)s_send(int counter __attribute__((unused)))
{
  return;
}
"""

lcm_run_template = """\
void
%(classname)s_telemetry_send(void)
{
  static int counter = 0;

%(send_all)s

  if (counter >= (int) (1.0/(%(timestep)s))) counter = 0;
  else counter++;
}
"""

## Init settings
lcm_settings_init_template = """
void
%(varname)s_settings_init(const char *provider)
{
  %(classname)s_lcm_init(provider);
  %(classname)s_lcm_subscribe_chan(%(typename)s, &%(classname)s_%(varname)s_setter, NULL, "%(classname)s_%(typename)s_%(varname)s_set");
}
"""

lcm_settings_init_custom_chan_template = """
void
%(varname)s_settings_init(const char *provider)
{
  %(classname)s_lcm_init(provider);
  %(classname)s_lcm_subscribe_chan(%(typename)s, &%(classname)s_%(varname)s_setter, NULL, "%(channel)s");
}
"""

lcm_settings_init_nop_template = """
void
%(varname)s_settings_init(const char *provider __attribute__((unused)))
{
  return;
}
"""

lcm_settings_init_prototype = """\
void %(varname)s_settings_init(const char *provider); 
"""

lcm_settings_init_call_template = """  %(varname)s_settings_init(provider); \\"""
lcm_settings_init_null_template = """  %(classname)s_%(varname)s_setter(NULL, NULL, NULL, NULL); \\
"""

lcm_settings_init_class_template = """
/* Initialize all the LCM classes and set all settings values to their
   default values as defined in XML */
#define %(classname)s_settings_init(provider) {      \\
%(init_calls)s
%(null_calls)s }
"""

lcm_settings_init_all_template = """
/* Initialize all the LCM classes and set all settings values to their
   default values as defined in XML */
#define settings_init(provider) {      \\
%(init_calls)s }
"""

## Run settings
lcm_settings_prototype = """
void %(classname)s_%(varname)s_setter(const lcm_recv_buf_t *rbuf,  
                                      const char *channel,
                                      const %(classname)s_%(typename)s *msg,                            
                                      void *user);
"""

lcm_settings_func_template = """
void 
%(classname)s_%(varname)s_setter(const lcm_recv_buf_t *rbuf __attribute__((unused)),  
                                 const char *channel __attribute__((unused)),                 
                                 const %(classname)s_%(typename)s *new,                                      
                                 void *user __attribute__((unused)))
{
%(field_settings)s
  %(classname)s_lcm_send_chan(&%(varname)s, %(typename)s, "%(classname)s_%(typename)s_%(varname)s_ack");
}
"""

lcm_settings_field_template_mm = """
  if (new == NULL) {
    %(varname)s.%(name)s = %(default)s;
    return;
  }
  if (new->%(name)s > %(max)s)
    %(varname)s.%(name)s = %(max)s;
  else if (new->%(name)s < %(min)s)
    %(varname)s.%(name)s = %(min)s;
  else
    %(varname)s.%(name)s = new->%(name)s;
"""

lcm_settings_field_template_absbound = """
  if (new == NULL) {
    %(varname)s.%(name)s = %(default)s;
    return;
  }
  if (fabs(new->%(name)s) > %(absmax)s)
    %(varname)s.%(name)s = copysign(%(absmax)s, new->%(name)s);
  else
    %(varname)s.%(name)s = new->%(name)s;
"""

lcm_send_settings_template = """
void
%(classname)s_%(varname)s_set(%(classname)s_%(typename)s *new)
{
  %(classname)s_lcm_send(new, %(typename)s);
}
"""

lcm_check_all_template = """
#define settings_check() { \\
%(run_calls)s }
"""

lcm_check_call_template = """
#define %(classname)s_settings_check() { \\
  lcm_check(%(classname)s_lcm.lcm, %(classname)s_lcm.fd);  \\
}
"""

## Form structs per-class for telemetry
lcm_struct_template = """
typedef struct %(classname)s_lcm_t {
  lcm_t *lcm;
%(class_struct_pointers)s
  int fd;
} %(classname)s_lcm_t;

extern %(classname)s_lcm_t %(classname)s_lcm;
"""

## Simple lcm i/o interface for manually sending and manipulating LCM
## messages
lcm_macros_template = """

#define %(classname)s_lcm_send_chan(msg, msgtype, chan) {                \\
    %(classname)s_ ## msgtype ## _publish(%(classname)s_lcm.lcm, chan, (const %(classname)s_ ## msgtype *) msg); \\
  }

#define %(classname)s_lcm_send(msg, msgtype) {                                \\
  %(classname)s_lcm_send_chan(msg, msgtype, "%(classname)s_" #msgtype);                 \\
  }

/* type      the type of the message (e.g. est2User_t) 
 * handler   a function of type lcm_msg_handler_t (e.g. &update_e2u)
 * data      pointer to be passed to handler whenever it's called
 * channel   optional channel name 
 */

#define %(classname)s_lcm_subscribe_chan(type, handler, data, channel) {                        \\
  %(classname)s_lcm.type ## _sub =                                                          \\
    %(classname)s_ ## type ## _subscribe(%(classname)s_lcm.lcm, channel, handler, data);       \\
  }

/* assume channel the same as the type */

#define %(classname)s_lcm_subscribe(type, handler, data) {                                 \\
  %(classname)s_lcm_subscribe_chan(type, handler, data, "%(classname)s_" # type);                      \\
  }


/* Generate a handler that does nothing but copy the message to the
 * given pointer. */

#define %(classname)s_lcm_copy_handler(type)                                               \\
  static void                                                                   \\
  type ## _handler(const lcm_recv_buf_t *rbuf __attribute__((unused)),  \\
                   const char *channel __attribute__((unused)),                 \\
                   const %(classname)s_ ## type *msg,                                      \\
                   void *user)                                         \\
  {                                                                             \\
    if (user)                                                           \\
      memcpy((type *)user, msg, sizeof(type));                          \\
  }                                                                             

/* Subscribe to the handler generated above for the same type. */

#define %(classname)s_lcm_subscribe_cp(type, data) {                                       \\
    %(classname)s_lcm_subscribe(type, & type ## _handler, data);          \\
  }

#define %(classname)s_lcm_subscribe_chan_cp(type, data, chan) {                \\
    %(classname)s_lcm_subscribe_chan(type, & type ## _handler, data, chan);         \\
  }


#define %(classname)s_lcm_unsubscribe(type) {                                              \\
  %(classname)s ## type ## _unsubscribe(%(classname)s_lcm.lcm, %(classname)s_lcm. ## type ## _sub);      \\
  }

/* In case you want to change handlers, channel or user data.  Note
 * that you've gotta pass all the arguments again (for now). */

#define %(classname)s_lcm_resubscribe_chan(type, handler, data, channel) {         \\
  %(classname)s_lcm_unsubscribe(type);                                             \\
  %(classname)s_lcm_subscribe_chan(type, handler, data, channel);                  \\
  }

#define %(classname)s_lcm_resubscribe(type, handler, data) {                       \\
  %(classname)s_lcm_unsubscribe(type);                                             \\
  %(classname)s_lcm_subscribe(type, handler, data);                                \\
  }

"""

## Two utility parent classes that let you write properly formed C and
## LCM files.
class CHeader():
    def __init__(self):
        pass

    def to_h(self, name, output_f):
        cf = open(name + ".h", 'w')
        cf.write(h_file_head + "\n")
        hname = name.replace("/", "_").upper()
        cf.write("#ifndef __" + hname + "_H__\n")
        cf.write("#define __" + hname + "_H__\n\n")
        output_f(cf)
        cf.write("\n\n#endif // __" + hname + "_H__\n")
        cf.close()
        print "Autogenerated file `" + name + ".h'."

    def cpp_wrap(self, strin):
        return """
#ifdef __cplusplus
extern "C"{
#endif

%(str)s

#ifdef __cplusplus
}
#endif
""" % {"str":strin}

class CCode():
    def __init__(self):
        pass
    def to_c(self, name, output_f):
        def tmp_output_f(cf):
            cf.write("#include \"" + name + ".h\"\n\n")
            output_f(cf)
        self.to_c_no_h(name, tmp_output_f)

    def to_c_no_h(self, name, output_f):
        cf = open(name + ".c", "w")
        cf.write(h_file_head + "\n")
        output_f(cf)
        cf.close()
        print "Autogenerated file `" + name + ".c'."

class LCMFile():
    def __init__(self):
        pass
 
    def to_lcm(self, name, output_f):
        lf = open(name + ".lcm", 'w')
        lf.write(h_file_head + "\n")
        lf.write("package " + name + ";\n")
        output_f(lf)
        lf.close()
        print "Autogenerated file `" + name + ".lcm'."

        # for s in structs[classname]:
        #     lf.write(s.to_lcm())
        #     lf.write("\n");
   

class LCMStruct():
    """This is the native format for structs we need to use.  You can
    convert to and from XML, C, LCM and Python."""
    def __init__(self, msg, classname):
        self.attrib = msg.attrib
        self.name = msg.attrib['name']
        self.members = msg.getchildren()
        self.classname = classname

    def field_to_cstring(self, field):
        # handle pointers
        ptr = None
        if 'ptr' in field.attrib:
            ptr = field.attrib['ptr'].count('*')
            if ptr == 0 and field.attrib['ptr']:
                ptr = int(field.attrib['ptr'])
        # field name
        fstr = field.attrib['type'] + " " 
        fstr += field.attrib['name']
        if ptr: fstr += '[1]'*ptr 
        # handle arrays
        if 'array' in field.attrib:
            sizes = field.attrib['array'].rsplit(",")
            for s in sizes:
                fstr += "[" + s + "]"
        fstr += ";"
        # comments and units (appended to comment)
        if 'comment' in field.attrib or 'unit' in field.attrib:
            fstr += "\t\t" + "// "
        if 'unit' in field.attrib:
            fstr += "(" + field.attrib['unit'] + ") -- "
        if 'comment' in field.attrib:
            fstr += field.attrib['comment'] 
        fstr += "\n"
        return fstr

    def to_c(self):
        """This emits additional C code (struct definitions) for all
        the messages described, plus the #define-d enum contents since
        LCM doesn't implement enum types."""
        outstr = ""
        if self.attrib.has_key('__base__'):
            outstr += "#ifndef " + self.name.upper() + "\n"
            outstr += "#define " + self.name.upper() + "\n"
        outstr += "typedef struct " + self.name + " {\n" # self.classname + "_" + 
        if 'comment' in self.attrib:
            outstr += "/* " + self.attrib['comment'] + " */\n"
        for m in self.members: 
            outstr += "  " + self.field_to_cstring(m)
        outstr += "} " + self.name + ";\n" # + self.classname + "_" 
        if self.attrib.has_key('__base__'):
            outstr += "#endif // " + self.name.upper() + "\n"
        return outstr
        
    def to_lcm(self):
        """This emits the LCM configuration file based on the structs
        described in XML."""
        outstr = "struct " + self.name + " {\n" # self.classname + "_" + 
        if 'comment' in self.attrib:
            outstr += "/* " + self.attrib['comment'] + " */\n"
        for m in self.members: 
            outstr += "  " + self.field_to_cstring(m)
        outstr += "}\n"
        return outstr

    def to_include(self):
        pass
        
    def to_python(self):
        """This emits Python classes (mainly just with attributes)
        based on the messages described in XML, along with hashes for
        the enums since LCM doesn't implement enum types."""
        print "Compiling XML directly to python classes is not implemented. --MP"

class LCMEnum():
    def __init__(self, enum, clname):
        self.attrib = enum.attrib
        self.name = enum.attrib['name']
        self.classname = clname

    def to_c(self):
        estr = ""
        if 'comment' in self.attrib:
            estr += "/* " + self.attrib['comment'] + " */\n"
        if self.attrib.has_key('__base__'):
            estr += "#ifndef " + self.name.upper() + "\n"
            estr += "#define " + self.name.upper() + "\n"
        estr += "typedef " 
        estr += "enum {\n"
        for f in self.attrib['fields'].rsplit(','):
            estr += "  " + f.strip() + ",\n"
        estr += "} "
        if 'typedef' in self.attrib:
            estr += self.attrib['typedef']
        else:
            estr += self.attrib['name']
        estr += ";\n"
        if self.attrib.has_key('__base__'):
            estr += "#endif // " + self.name.upper() + "\n"
        return estr

    def to_c_defines(self):
        """We use #defines to implement a hacky enum.  Simply typedef
        int to command_t and use the preprocessor values.  The
        autogenerated code takes care of the rest.  This means that
        you still have to extract the "val" field or just typecast
        it."""

        estr = ""
        if 'comment' in self.attrib:
            estr += "/* " + self.attrib['comment'] + " */\n"
        estr += "typedef int " + self.attrib['name'] + ";\n"
        defenum = zip(self.attrib['fields'].rsplit(','), range(len(self.attrib['fields'])-1))
        for f, n in defenum:
            estr += "#define " + f.strip() + " " + str(n) + "\n"
        return estr

    def to_lcm(self):
        estr = "struct " + self.attrib['name'] + " {\n  int32_t val;\n}\n"
        return estr

    def to_include(self):
        pass

    def to_python(self):
        print "Compiling XML directly to python classes is not implemented. --MP"

class CStructClass(CHeader, LCMFile, CCode):
    def __init__(self, name, structs):
        self.name = name
        self.structs = structs

    def include_headers(self):
        return "\n".join(["#include \"" + lcm_folder + "/" 
                          + self.name + "_" + x.name + 
                          ".h\"\n" for x in self.structs])

    def to_structs_h(self):
        def structs_f(cf):
            cf.write("#include <stdint.h>\n\n");
            for s in self.structs:
                print "writing" , s.name
                cf.write(s.to_c())
                cf.write("\n");
        self.to_h(self.name + "_types", structs_f)
        
    def to_structs_lcm(self):
        def structs_f(cf):
            for s in self.structs:
                cf.write(s.to_lcm())
                cf.write("\n")
        self.to_lcm(self.name, structs_f)
    
class TelemetryMessage(CHeader, CCode):
    def __init__(self, hsh):
        self.a = hsh
        self.a['varname'] = self.a['name']
        self.a['typename'] = self.a['type']
        self.a['simrate'] = self.a['sim']
        self.a['flightrate'] = self.a['flight']
        self.a['sim_flag'] = sim_flag
        self.a['timestep'] = timestep

    def to_telemetry_function(self):
        """This emits a small function that relies on a variable being
        captured by scoping rules to send the struct as telemetry."""

        filename = telemetry_folder + "/%(classname)s_%(typename)s_%(varname)s" % self.a
        def th(cf):
            cf.write("#include <%(classname)s_telemetry.h>\n" % self.a)
            cf.write("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");
            if self.a.has_key('channel'):
                cf.write(lcm_telemetry_custom_chan_template % self.a)
            else:
                cf.write(lcm_telemetry_template % self.a)
            cf.write("#ifdef __cplusplus\n}\n#endif\n\n");
        self.to_h(filename, th)

    def to_telemetry_prototype(self, cf):
        """This emits a function prototype for the telemetry capture
        function created above."""
        
        proto = """\
void %(classname)s_%(varname)s_send(int counter); \n""" % self.a
        cf.write(proto)

    def to_telemetry_nop(self):
        filename = stubs_folder + "/%(classname)s_%(typename)s_%(varname)s_telem_stub" % self.a
        def stub_f(cf):
            cf.write(lcm_telemetry_nop_template % self.a)
        self.to_c_no_h(filename, stub_f)


class Telemetry(CHeader, LCMFile, CCode):
    """This class represents a Telemetry class as taken from the XML
    config."""
    def __init__(self, classname, messages, simrate, flightrate, class_structs):
        self.messages = messages
        self.a = {}
        self.a['classname'] = classname
        self.a['num_msgs'] = len(messages)
        self.a['simrate'] = simrate
        self.a['flightrate'] = flightrate
        self.a['sim_flag'] = sim_flag
        self.a['timestep'] = timestep
        self.a['send_all'] = "\n".join(map(lambda msg: "  " + self.a["classname"] + "_" 
                                           + msg.a['varname'] + "_send(counter);" 
                                           , self.messages))
        self.a['class_struct_pointers'] = self._class_struct_pointers(class_structs)
        self.a['class_struct_includes'] = self._class_struct_includes(class_structs)

    def _class_struct_pointers(self, structs):
        out = []
        formatstr = "  %(classname)s_%(typename)s_subscription_t *%(typename)s_sub;" 
        if (structs):
            out = [formatstr % {"classname":self.a['classname'], "typename":s.name} for s in structs]
        else:
            ## If this is an orphaned telemetry module, we'll only add
            ## pointers for structs we know about.
            out = [formatstr % m.a for m in self.messages]
        return "\n".join(out)

    def _class_struct_includes(self, structs):
        out = []
        formatstr = "#include \"%(lcm_folder)s/%(classname)s_%(typename)s.h\""
        if (structs):
            out = [formatstr % 
                   {"classname":self.a['classname'], 
                    "typename":s.name, 
                    "lcm_folder":lcm_folder} for s in structs]
        else:
            ## Orphaned telemetry module; include only types we know
            ## about
            out = [formatstr % 
                   {"classname":self.a['classname'],
                    "typename":m.a['typename'],
                    "lcm_folder":lcm_folder} for m in self.messages]
        return "\n".join(out)

    def telemetry_run_function(self, cf):
        """Generate a top-level function for sending all appropriate
        telemetry messages (simply calling all the sub-functions for
        telemtry) """
        cf.write(lcm_run_template % self.a)

    def telemetry_includes(self, cf):
        cf.write(self.a['class_struct_includes'])
        
    def telemetry_nops(self):
        for m in self.messages:
            m.to_telemetry_nop()

    def telemetry_lcm_struct(self, cf):
        cf.write(lcm_struct_template % self.a)

    def telemetry_prototypes(self, cf):
        """Generate a series of prototypes for the individual
        telemetry message sending functions"""
        for m in self.messages:
            m.to_telemetry_prototype(cf)

    def telemetry_functions(self):
        for m in self.messages:
            m.to_telemetry_function()

    def to_telemetry_c(self):
        def telem_f(cf):
            cf.write("#include \"lcm_interface.h\"\n")
            cf.write("#include \"%(classname)s_types.h\"\n\n" % self.a)
            cf.write("%(classname)s_lcm_t %(classname)s_lcm;\n\n" % self.a)
            self.telemetry_prototypes(cf)
            cf.write(lcm_init_template % self.a)
            self.telemetry_run_function(cf)

        self.to_c(self.a['classname']+"_telemetry", telem_f)

    def to_telemetry_h(self):
        self.telemetry_functions()
        def telem_f(cf):
            self.telemetry_includes(cf)
            self.telemetry_lcm_struct(cf)
            protos = "\n".join([lcm_init_prototype_template % self.a, 
                                lcm_run_prototype_template % self.a])
            cf.write(self.cpp_wrap(protos))
            cf.write(lcm_macros_template % self.a)
        self.to_h(self.a['classname'] + "_telemetry", telem_f)

class LCMSetting(CHeader, LCMFile, CCode):
    def __init__(self, hsh, fields):
        self.a = hsh
        self.fields = fields
        self.name = self.a['name']
        self.a['typename'] = self.a['type']
        ffs = []
        for f in self.fields:
            f['varname'] = self.a['varname']
            if 'absmax' in f:
                ffs.append(lcm_settings_field_template_absbound % f)
            else:
                ffs.append(lcm_settings_field_template_mm % f)
        self.a['field_settings'] = "\n".join(ffs)

    def to_settings_file(self):
        basename = "%(classname)s_%(typename)s_%(varname)s" % self.a 
        filename = settings_folder + "/" + basename
        def sf(cf):
            cf.write("#include <lcm/lcm.h>\n" % self.a)
            cf.write("#include <math.h>\n" % self.a)
            cf.write("#include <telemetry/%(basename)s.h>\n" % {"basename":basename})
            cf.write("#include <%(classname)s_settings.h>\n" % self.a)
            if self.a.has_key('channel'):
                cf.write(lcm_settings_init_custom_chan_template % self.a)
            else:
                cf.write(lcm_settings_init_template % self.a)
            cf.write(lcm_settings_func_template % self.a)
        self.to_h(filename, sf)

    def to_settings_nop(self):
        filename = stubs_folder + "/%(classname)s_%(typename)s_%(varname)s_setting_stub" % self.a
        def stub_f(cf):
            cf.write(lcm_settings_init_nop_template % self.a)
        self.to_c_no_h(filename, stub_f)

    def to_settings_prototype(self, cf):
        cf.write(lcm_settings_prototype % self.a)

class Settings(CHeader, LCMFile, CCode):
    def __init__(self, name, children, class_structs):
        self.name = name
        self.settings = children
        self.a = {}
        self.a['classname'] = name
        self.a['class_struct_includes'] = self._class_struct_includes(class_structs)
        
    def settings_functions(self):
        for s in self.settings:
            s.to_settings_file()

    def settings_prototypes(self, cf):
        cf.write("/* Prototypes for all the functions defined in settings/ folder */\n")
        for s in self.settings:
            cf.write(lcm_settings_prototype % s.a)
            cf.write(lcm_settings_init_prototype % s.a)

    def settings_nops(self):
        for s in self.settings:
            s.to_settings_nop()

    def _class_struct_includes(self, structs):
        out = []
        formatstr = "#include \"%(lcm_folder)s/%(classname)s_%(typename)s.h\""
        if (structs):
            out = [formatstr % 
                   {"classname":s.classname, 
                    "typename":s.name, 
                    "lcm_folder":lcm_folder} for s in structs]
        else:
            ## Orphaned settings module; include only types we know
            ## about
            out = [formatstr % 
                   {"classname":name,
                    "typename":m.a['typename'],
                    "lcm_folder":lcm_folder} for s in self.settings]
        return "\n".join(out)

    def settings_includes(self, cf):
        cf.write(self.a['class_struct_includes'])

    def to_settings_periodic(self):
        pass

    def to_settings_c(self):
        pass

    def to_settings_h(self):
        self.settings_functions()
        def settings_f(cf):
            cf.write("#include \"%(classname)s_types.h\"\n\n" % self.a)
            cf.write("#include \"%(classname)s_telemetry.h\"\n\n" % self.a)
            self.settings_prototypes(cf)
            all_inits = [lcm_settings_init_call_template % s.a for s in self.settings]
            all_nulls = [lcm_settings_init_null_template % s.a for s in self.settings]
            # Make initialization macro
            cf.write(lcm_settings_init_class_template 
                     % {"init_calls":"\n".join(all_inits), 
                        "null_calls":"\n".join(all_nulls), 
                        "classname":self.name})
            cf.write(lcm_check_call_template % self.a);
            
        self.to_h(self.name + "_settings", settings_f)

def filter_structs(clname, msgs):
    outstructs = []
    for msg in msgs:
        if msg.tag == 'message':
            outstructs.append(LCMStruct(msg, clname))
        elif msg.tag == 'enum':
            outstructs.append(LCMEnum(msg, clname))
        else:
            print parse_type_error % {"msg_tag":msg.tag, "filename":"types"}
    return outstructs
    
def filter_messages(clname, msgs, cl):
    outstructs = []
    for msg in msgs:
        if msg.tag == 'message':
            if not msg.attrib.has_key('flight'):
                msg.attrib['flight'] = cl.attrib['flight']
            if not msg.attrib.has_key('sim'):
                msg.attrib['sim'] = cl.attrib['sim']
            msg.attrib['classname'] = clname
            outstructs.append(TelemetryMessage(msg.attrib))
        else:
            print parse_type_error % {"msg_tag":msg.tag, "filename":"telemetry"}
    return outstructs

def filter_settings(clname, structs):
    bounds = ['min', 'max', 'absmax']
    die = 0
    outstructs = []
    ms = []
    for s in structs:
        fields = s.getchildren()
        ## skip field type checks for now
        # else:
        #     print "Warning: XML parser encountered an settings section of type " + section.tag 
        #     + " in file `settings.xml.'  Either the XML is broken (typo?) or support for this type is not yet implemented."

        for f in fields:
            attrs = f.attrib
            notfound = []
            ## Try to get attributes for setting from the section if
            ## they're not in the field.
            for sp in (['default'] + bounds):
                if not sp in f.attrib and sp in s.attrib:
                    attrs[sp] = s.attrib[sp]
                else:
                    notfound.append(sp)

            ## Make sure we don't have any unbounded settings values.
            ## That's Dangerous!
            if (not 'min' in attrs or not 'max' in attrs) and (not 'absmax' in attrs):
                print parse_settings_nobounds % {"f":f.attrib['name'], "s":s.attrib['name']}
                # die += 1
            else:
                for b in bounds:
                    try:
                        notfound.remove(b)
                    except ValueError:
                        pass
                    
            ## Bail if there's a problem
            for nf in notfound:
                print parse_settings_noval % {"sp":nf, "f":f.attrib['name'], "s":s.attrib['name']}
                # die += 1 

            ## All OK; create a new hash that eventually becomes a setting
            attrs['classname'] = clname
            ms.append(attrs)
        s.attrib['classname'] = clname
        outstructs.append(LCMSetting(s.attrib, ms))
    if die:
        print "Lots of settings errors detected; cannot continue code generation."
        exit(1)
    return outstructs

def parse_types():
    ## Walk through the types, telemetry and settings definitions and
    ## create tuples of those that line up
    basestructs = []
    classes = []
    structh = {}
    telemh = {}
    seth = {}
    for cl in ET.ElementTree().parse(config_folder + "/types.xml").getchildren():
        if cl.tag == 'class':
            structh[cl.attrib['name']] = cl
        elif cl.tag in ['struct', 'enum', 'message']:
            cl.attrib['__base__'] = True
            basestructs.append(cl)
    for cl in ET.ElementTree().parse(config_folder + "/telemetry.xml").getchildren():
        telemh[cl.attrib['name']] = cl
    for cl in ET.ElementTree().parse(config_folder + "/settings.xml").getchildren():
        seth[cl.attrib['name']] = cl

    basestructs.reverse()
    for clname, cl in structh.iteritems():
        msgs = cl.getchildren()
        [msgs.insert(0, b) for b in basestructs]
        outstructs = filter_structs(clname, msgs)
        tt = None
        ss = None
        if clname in telemh:
            tel = telemh[clname]
            teout = filter_messages(clname, tel.getchildren(), tel)
            tt = Telemetry(clname, teout, tel.attrib['sim'], tel.attrib['flight'], outstructs)
            del telemh[clname]
        if clname in seth:
            sett = seth[clname]
            setout = filter_settings(clname, sett.getchildren())
            ss = Settings(clname, setout, outstructs)
            del seth[clname]

        classes.append((CStructClass(clname, outstructs), tt, ss))
        
    for clname, cl in seth.iteritems():
        ## If telemetry classes are still defined without a
        ## corresponding types class, we'll assume the user means it
        ## and has implemented the types on his own
        print "Warning: orphaned settings class `" + clname + "'; structs may not be defined."
        setts = cl.getchildren()
        setout = filter_settings(clname, setts)
        tt = None
        if clname in telemh:
            tel = telemh[clname]
            teout = filter_messages(clname, tel.getchildren(), tel)
            tt = Telemetry(clname, teout, tel.attrib['sim'], tel.attrib['flight'], outstructs)
            del telemh[clname]
        classes.append((None, tt, Settings(clname, setout, None)))
        
    for clname, cl in telemh.iteritems():
        print "Warning: orphaned telemetry class `" + clname + "'; structs may not be defined."
        msgs = cl.getchildren()
        outstructs = filter_messages(clname, msgs)
        classes.append((None, Telemetry(clname, outstructs, cl.attrib['sim'], cl.attrib['flight']), None))

    return (classes, set(structh.keys() + telemh.keys() + seth.keys()))

class CDefine():
    def __init__(self, node, prefix):
        if node.attrib.has_key('prefix'):
            self.prefix = prefix + node.attrib['prefix']
        elif node.tag not in ['section', 'include']:
            self.prefix = prefix + node.tag.upper()
        else:
            self.prefix = prefix
        self.defines = {}
        self.sub = {}
        for c in node.getchildren():
            if c.tag not in ['define', 'servo']:
                self.sub[c.attrib['name']] = CDefine(c, self.prefix)
            elif c.tag == 'define':
                self.defines[c.attrib['name']] = c
            else:
                print "servos not implemented, sucka biznatch!"
        if node.attrib.has_key('subtree'):
            for k in node.attrib['subtree']:
                self.sub[k.attrib['name']] = CDefine(k, self.prefix)

    def to_define_h(self, cf):
        for n, d in self.defines.iteritems():
            cf.write("#define " + self.prefix + n + " " + d.attrib['value'] + "\n");
        for n, s in self.sub.iteritems():
            s.to_define_h(cf)

class CDefineFile(CHeader):
    def __init__(self, tree):
        self.name = tree.attrib['name']
        self.nodes = [CDefine(tt, '') for tt in tree.getchildren()]

    def to_define_h(self):
        def define_h_writer(cf):
            for n in self.nodes:
                n.to_define_h(cf)
        print "writing defines file for ", self.name
        self.to_h("airframes/" + self.name, define_h_writer)
                
def parse_airframe(airframefile):
    try: 
        print airframefile
        af = ET.ElementTree().parse(airframefile)
    except IOError:
        raise IndexError ## i'm so, so sorry, but Greg needs this soon
    except expat.ExpatError as e:
        print "Error parsing airframe config file `" + airframefile + "':", e
        exit(1)
    dielater = False
    for k in af.getchildren():
        if k.attrib.has_key('href'):
            includename = dirname(airframefile) + "/" + k.attrib['href']
            try:
                k.attrib['subtree'] = ET.ElementTree().parse(includename).getchildren()
            except expat.ExpatError as e:
                print "Error parsing airframe config file `" + includename + "':", e
                dielater = True
    return CDefineFile(af)

if __name__ == '__main__':
    try:
        airframe = parse_airframe(argv[1])
    except IndexError:
        print "No airframe file given on command line; skipping."
    else:
        airframe.to_define_h()
    (cls, classes) = parse_types()
    outtelem = []
    outsettings = []
    for c in cls:
        ## Is there a struct class here?
        try:
            c[0].to_structs_h()
        except AttributeError: 
            pass
        else:
            c[0].to_structs_lcm()
        ## Is there a telemetry class?
        try:
            c[1].to_telemetry_h()
        except AttributeError:
            print "Note: no telemetry configured for class " + c[0].name
        else:
            c[1].to_telemetry_c()
            c[1].telemetry_nops()
            outtelem.append(c[1])
        try:
            c[2].to_settings_h()
        except AttributeError:
            print "Note: no settings configured for class " + c[0].name
        else:
            c[2].settings_nops()
            outsettings.append(c[2])

    ## Make lcm_settings_auto.h for inclusion into handwritten files
    def settings_header(cf):
        inits = []
        for s in outsettings:
            print "setting:", s.name
            cf.write("#include \"%(name)s_settings.h\"\n" % {"name":s.name})
            s.settings_includes(cf)
        checks = "".join(["  %(classname)s_settings_check(); \\" % s.a + "\n" for s in outsettings])
        cf.write("\n\n" + lcm_check_all_template % {"run_calls":checks})
        inits = "".join(["  %(classname)s_settings_init(provider); \\" % s.a + "\n" for s in outsettings])
        cf.write("\n\n" + lcm_settings_init_all_template % {"init_calls":inits})

    ## Make lcm_telemetry_auto.h for inclusion into handwritten files
    ## (right now just lcm_telemetry_new.h)
    def telemetry_header(cf):
        for t in outtelem:
            cf.write("\n#include \"%(classname)s_telemetry.h\"\n" % t.a)
            t.telemetry_includes(cf)
        inits = "".join([lcm_init_call_template % t.a + "\n" for t in outtelem])
        runs = "".join([lcm_run_call_template % t.a + "\n" for t in outtelem])
        cf.write("\n\n" + lcm_init_all_template % {"init_calls":inits})
        cf.write("\n\n" + lcm_run_all_template % {"run_calls":runs})

    clas=open("classes.dat", "w")
    [clas.write(cl + " ") for cl in classes]
    clas.close()
    lcm_auto = CHeader()
    lcm_auto.to_h("lcm_telemetry_auto", telemetry_header)
    lcm_auto.to_h("lcm_settings_auto", settings_header)
        
   
